palidromic substring

class Solution {
public:
    int countSubstrings(string s) {
        int ret = 0;
        bool dp[s.size()][s.size()];
        
        dp[0][0] = true;
        
        for(int i = 0; i < s.size(); i++) {
            for(int j = 0; j <= i; j++) {
                if((s[j] == s[i]) && (i - j <= 2 || dp[j + 1][i - 1])) {
                    ret++;
                }
            }
        }
        return ret;
    }
};

Decode String

class Solution {
public:
    string decodeString(string s) {
        string ret;
        dfs(0, 0, s, ret);
        return ret;
    }
    
    void dfs(int start, int time, string s, string ret) {
        
        for(int i = start; i < s.size(); i++) {
            if(s[i] <= '9' && s[i] >= '0') {
                return dfs(i + 1, s[i] - '0', s, ret);
            } else if(s[i] > '9' && s[i] < '0' && s[i] != '[' && s[i] != ']') {
                for(int j = 0; j < time; j++) {
                    ret += s[j];   
                }
            } else {
                i++;
            }
        }     
    }
};


Longest Increasing Subsequence

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        
        int ret = 0;
        vector<int> dp(nums.size(), 1);
        
        for(int i = 0; i < nums.size(); i++) {
            for(int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }    
            ret = max(ret, dp[i]);
        }
        
        return ret;
    }
};

79. Word Search

class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        return bfs(0, 0, 0, word, board);
    }
    
    bool bfs(int index, int i, int j, string& word, vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
    
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                
                if(board[i][j] = '0' || board[i][j] != word[index])
                    continue; 
                
                if(board[i][j] == word[index] && index == word.size() - 1) 
                    return true;
                 
                board[i][j] = '0';
                
                if(board[i][j] = word[index]) {
                    if(index + 1 < word.size()) {
                        if(i + 1 < m) 
                            return bfs(index + 1, i + 1, j, word, board);
                        if(i - 1 >= 0) 
                            return bfs(index + 1, i - 1, j, word, board);
                        if(j + 1 < n)
                            return bfs(index + 1, i, j + 1, word, board);
                        if(j - 1 >= 0)
                            return bfs(index + 1, i, j - 1, word, board);
                    }       
                }
            }
        }
        
        return false;
    }
};

class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        return bfs(0, 0, 0, word, board);
    }
    
    bool bfs(int index, int i, int j, string& word, vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
        
        if(index >= word.size() || i < 0 || i > m - 1 || j < 0 || j > n -1 ) {
            return false;
        }  
    
        if(board[i][j] = '0' || board[i][j] != word[index])
            return false; 
                
        if(board[i][j] == word[index] && index == word.size() - 1) 
            return true;
                
        if(board[i][j] = word[index]) {
            board[i][j] = '0';
            bool flag = bfs(index + 1, i + 1, j, word, board) || bfs(index + 1, i - 1, j, word, board) || bfs(index + 1, i, j + 1, word, board) || return bfs(index + 1, i, j - 1, word, board);
            return flag;
            board[i][j] = word[index];
        }       
                
        return false;
    }
};

word break 

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> set(wordDict.begin(), wordDict.end());
        bool ret = dsf(s, 0, set);
        return ret;
    }
    
    bool dfs(string s, int index, unordered_set<string>& set) {
        
        if(index == s.size() - 1) {
            return true;
        }
        
        for(int i = index; i < s.size(); i++) {
            if(set.count(s.subStr(index, i - 1)) && dfs(s, i + 1, set)) {
                return true;
            }
        }
        
        return false;
    }
};

word break DP

class solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        bool dp[s.size()];
        dp[0] = true;
        
        for(int i = 0; i < s.size(); i++) {
            for(int j = 0; j < i; j++) {
                dp[i] = wordSet.count(s.substr(j, i - j)) && dp[j];
                if (dp[i])
                    break;
            }
        }
        return dp[s.size() - 1];
    }
}


valid binary seavalid binary search treerch tree
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root);
    }
    
    bool dfs(TreeNode *root) {
        if(!root) 
            return true;
        if(root->left && root->val < root->left->val)
            return false;
        if(root->right && root->val > root->right->val)
            return false;
            
        return dfs(root->left) && dfs(root->right);
    }
};


serialize and deserialize 

class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream ret;
        dfs(root, ret);
        return ret.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringsstream in(data);
        return deserialize(in);
    }
    
private:
    
    void dfs(TreeNode *root, ostringstream& ret) {
        if(!root)
            ret << "#";
        
        ret << root->val;
        
        if(!root->left) {
            dfs(root->left, ret);
        }
        
        if(!root->right) {
            dfs(root->right, ret);
        }
            
    }
    
    TreeNode* deserialize(istringsstream& data) {
        if(data[index] == '#') {
            return NULL;
        }
        
        string tmp;
        data >> tmp;
        TreeNode *root = new TreeNode(atoi(tmp));
        root->left = deserialize(data);
        root->right = deserialize(data);
        return root;
    }
};


perfect square

class Solution {
public:
    int numSquares(int n) {

        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;
        
        for(int i = 2; i <= n; i++) {
          for(int j = 1; j <= i; j++) {
            dp[i] = min(dp[i], dp[i - (j * j)] + 1);
          }  
        } 
        
        return dp[n];
    }
};

maximum product subarray // sign integer overflow...

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        
        int ret = nums[0];
        int dp_max[nums.size()];
        int dp_min[nums.size()];
        
        dp_max[0] = nums[0];
        dp_min[0] = nums[0];
        
        for(int i = 1; i < nums.size(); i++) {
            dp_max[i] = max(dp_max[i - 1] * nums[i], max(dp_min[i] * nums[i], nums[i]));
            dp_min[i] = min(dp_min[i - 1] * nums[i], min(dp_max[i] * nums[i], nums[i]));
            ret = max(dp_max[i], ret);
        }
        
        return ret;
    }
};


maximum square

class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        
        int max_len = matrix[0][0] - '0';
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        
        for(int i = 0; i < m; i++) {
            dp[i][0] = matrix[i][0] - '0';
        }
        
        for(int i = 0; i < n; i++) {
            dp[0][i] = matrix[0][i] - '0';
        }
                
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                if(matrix[i][j] == '0') {
                    dp[i][j] = 0;
                    continue;
                }
                    
                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                max_len = max(max_len, dp[i][j]);
            }
        }
        
        return max_len * max_len;
    }
};

longest substring without repeating characters

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        
        int ret = 0;
        int left = -1;
        unordered_map<char, int> char2index;
        int dp[s.size()] = {0};
        dp[0] = 1;
        
        for(int i = 1; i < s.size(); i++) {    
            if(!char2index.count(s[i])) {
                dp[i] = dp[i - 1] + 1;
            } else {
                if(char2index[s[i]] > left) {
                    dp[i] = i - char2index[s[i]];
                    left = char2index[s[i]];
                } 
            }   
            char2index[s[i]] = i;
            ret = max(ret, dp[i]);
        }
        
        return ret;
    }
};
